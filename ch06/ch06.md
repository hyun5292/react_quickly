# 6 React에서 이벤트 다루기

```
# 6-1 React에서 DOM 이벤트 다루기
	> 합성 이벤트(event 객체)
		: 내장 DOM 이벤트 객체를 개선한 것
	> bind()를 이용하면 이벤트 핸들러 함수가 클래스의 인스턴스인 React 엘리먼트에 대한 참조를 유지할 수 있음
	> bind(this)로 바인딩하지 않는 경우
		- this를 이용해서 해당 클래스를 참조할 필요가 없을 때
		- ES6+ 클래스 대신 예전 방식인 React.createClass()를 사용할 때, 이 때는 createClass()가 자동으로 바인딩 함
		- 화살표 함수를 사용할 때
	> 이벤트 핸들러를 생성자에서 바인딩하면 중복을 제거할 수 있고, 모든 바인딩을 한 곳에서 작성할 수 있음

	# 6-1-1 캡처 및 버블링 단계
		> 캡처 단계
			: window에서 대상 요소까지
			>> 이벤트 리스너를 등록할 때는 이벤트 이름 뒤에 Capture를 추가하여 작성
			>> 이벤트 전파를 중지시키거나 이벤트 간의 우선순위를 정할 수 있음
		> 대상 단계
			: 대상 요소에 도착
		> 버블링 단계
			: window로 되돌아 감

	# 6-1-2 React 이벤트 살펴보기
		> getEventListeners($0)
			: 특정 DOM노드에 연결된 이벤트 리스너를 확인하려면 개발자 도구 콘솔에서 전역 메서드인 getEventListeners($0) 실행
		> getEventListeners(document)
			: document에 연결된 이벤트
		> document.removeEventListener('이벤트이름', getEventListeners(연결된 곳).이벤트[0].listener, false)
			: 이벤트 제거

	# 6-1-3 React 합성 이벤트 객체 다루기
		> 브라우저 간의 차이로 인해 이벤트를 처리하는 코드를 작성할 때 크로스 브라우징 문제를 경험할 수 있음
		> React의 해결책은 브라우저 내장 이벤트를 감싸는 것
		> 합성 이벤트(SuntheticEvent)를 위한 특별한 클래스를 사용
		> SyntheticEvent 클래스의 인스턴스를 이벤트 핸들러에 전달하는 것
		> React에서 이벤트 핸들러를 작성할 때는 일반적인 클래스 메서드와 구분하기 위해 handle을 앞에 붙이고 mouseOver 같은 이벤트 이름을 넣거나, save처럼 수행하는 동작을 이름으로 사용
		> 내장 프로퍼티나 메서드를 찾을 수 없을 때는 nativeEvent를 통해서 브라우저의 내장 이벤트에 접근할 수 있음
			-> event.nativeEvent
		> 몇 가지 프로퍼티와 메서드
			- currentTarget: 이벤트를 캡처한 요소의 DOMEventTarget
			- target: DOMEventTarget, 이벤트가 발생한 요소
			- nativeEvent: DOMEvent, 브라우저 내장 이벤트 객체
			- preventDefault(): 링크나 폼 전송 버튼처럼 기본 동작을 방지하는 메서드
			- isDefaultPrevented(): 기본 동작이 방지되었을 때 실행하면 true를 반환
			- stopPropagation(): 이벤트 전파 중단
			- isPropagationStopped(): 이벤트 전파가 중단되었을 때 실행하면 true를 반환
			- type: 태그명 문자열
			- persist(): 합성 이벤트를 이벤트 풀에서 꺼낸 후 사용자 코드에서 이벤트에 대한 참조를 유지할 수 있도록 함
			- isPersistent(): 합성 이벤트를 이벤트 풀에서 꺼낸 경우 실행하면 true를 반환
		> 이벤트 핸들러가 한 번 실행되고 나면 합성 이벤트는 null이 되어 더이상 사용할 수 없음

	# 6-1-4 이벤트와 상태 사용하기

	# 6-1-5 이벤트 핸들러를 속성으로 전달하기
		> 상태비저장 컴포넌트에서 발생하는 이벤트를 처리하는 방법은 이벤트 핸들러를 상태비저장 컴포넌트의 props로 전달하고, 전달한 이벤트 핸들러 함수를 상태비저장 컴포넌트에서 실행하도록 하는 것
		> 둔한 프로젠테이션 컴포넌트와 영리한 컨테이너 컴포넌트
			- 프레젠테이션(둔한) 컴포넌트
				>> state가 없는 상태비저장 컴포넌트, 함수형 컴포넌트
				>> this.props.children을 자주 사용하고 DOM 요소를 렌더링 함
			- 컨테이너(영리한) 컴포넌트
				>> DOM 요소가 없을 때의 처리를 다룸
				>> state가 있음
				>> 고차 컴포넌트 패턴을 사용하고 데이터 소스에 연결하는 역할

	# 6-1-6 컴포넌트 간의 데이터 교환
```

```
# 6-2 React가 지원하지 않는 DOM 이벤트 처리하기
```

```
# 6-3 React를 다른 라이브러리와 통합하기: jQuery UI 이벤트
	> 비표준 이벤트를 사용하는 라이브러리와 통합해야 한다면 어떻게 해야 할까?
	> React에서 제공하지 않는 DOM 이벤트는 컴포넌트 라이프사이클 이벤트인 componentDidMount와 componentWillUnmount에서 등록할 수 있음

	# 6-3-1 버튼 통합하기
		> 첫 번째 방법, jQuery 슬라이더를 위한 이벤트를 React 컴포넌트에 등록하는 방법
			>> 강력하게 결합되어 객체가 서로 의존하게 됨(피하는 것이 좋음)

		> 두 번째 방법, window를 이용하는 방법

	# 6-3-2 라벨 통합하기
		> 이벤트를 감지할 수 있는 다른 객체를 jQuery와 React에서 동시에 사용하면 둘의 결합을 분리할 수 있음
			-> 느슨하게 결합된 패턴을 이용해 불필요한 의존성을 줄일 수 있어 좀 더 선호됨
		> 사용자 정의 이벤트를 전달해야 하는 경우도 있을 것
			-> 이벤트를 생성하여 데이터와 함께 window로 전달
```
